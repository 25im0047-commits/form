◉使用技術
・Supabase

◉目的
・supabaseのRLSを機能させること

◉ビジネスロジックのプロセス
1.ユーザーが予約を確定ボタンをクリックする
2.onSubmit関数に合わせてformというJSオブジェクトをformDataに変換
3.HandleSupabaseというサーバーアクションを実行しそこで渡してあげる
4.SupabaseにHTTPリクエストを送信時、formDataの内容を渡して保存できるようにする

◉プログラムの動き
1.server.tsでsupabaseとの接続とクッキー操作を可能にする
2.page.tsxで、supabaseとのデータベース接続を可能にする




◉DB設計
・databaseの型の考え方
・受け取っている値の型

◉supabaseのルールについて
・RSLを追加しているため、ポリシーがなくてはならない。
・ポリシーっていうのは、つうじょうのSQL文に対してちょっと特殊な形状のものを指すらしい

◉RSLポリシーについて
SupabaseのRSLについて
・セキュリティ的な観点からONにすることは必須である。これが必要な理由としては、supabaseはクライアントから直接データベースを叩く仕組みになっていて、これがない場合誰でもアクセスできてしまいデータを消されたり不要なデータを追加されてしまったり、構造を変化させられるリスクが伴うため。
・認可がない状態でデータを追加したりしようとしても、からの配列が返される
・RSLによって、クライアントから実行されるSQLに対して強制的に、ユーザーが認可を受けているかどうかを比較するWHERE句が追加される
・RSLというのはユーザーがログインした時に与えられるJWTというものの中に含まれている、uidを元にユーザーが認証済みユーザーなのかどうかを判断するような仕組みになっている。その際に、supabaseが発行した世紀のものかを比較し大丈夫ならそこからユーザーidであるsubというものを取得する。subとはsubjectの略である。そのJWTもセッションに含まれているもの。
・認証済みのユーザーと未認証のユーザーを分けてアクセス権を分離させる仕組みを作ることができる。
・これがある目的は、セキュリティのうち、スパムなどを警戒したものである。なぜ、スパムを防げるのかというと、ログインなどが必要で人ではないものがアクセスして大量送信するなどといったやばいことを防ぐことができる。
・RSLをつけないと、APIキーを見れる全体であるため、そこからデータ取得の権限を利用してデータを取得して、個人情報が漏れてしまう危険性が存在してしまう。

◉SSR
・CSRというブラウザ側に持ってきてデータをレンダリングするのに対して、サーバー側で行うので、読み込まれたものを渡すだけだから初回表示が早いのと、クライアントのスペっっくに依存しない。
また、HTMLの内容が全部読み込まれているのでSEOに強い。SEOに強い理由としては、Googleのクローラーの循環する仕組みとして、HTMLの構造を読み込むので、HTMLがしっかり構造化されているほど見つけてもらいやすくなる。
逆に、CSRはからのHTMLを返してしまうので、クローラーがほとんど見つけられないので、SEOに弱い。

◉supabase client


◉知識的疑問
・const cookieStore = await cookies()のcookies()とは？
⇨clientからhttpで送られてくるセッション情報があり、そこから全てのクッキーを取得してくるという処理である

・全体の{}とcookies:とは？
⇨{}は、 createServerClientの第三引数を渡すためのもので、オブジェクトリテラルと呼ばれる
⇨cookies:{}とはメソッド名を定義しているだけ

・以下のコードのげtAll()とは？また、内部のgetAll()とは？さらにmそれぞれの関係は？
getAll() {
    return cookieStore.getAll()
},
⇨外側のgetAll()の方は、シンプルに自分で定義した関数で内側は、Supabaseが提供するクッキーを全て取得する関数。具体的には、

・以下のコードの、cookiesToSetとは？
cookiesToSet.forEach(({ name, value, options }) =>
    cookieStore.set(name, value, options)
)
⇨cookiesToSetとは、supabase側から送られてくる、クッキーの情報みたいなもので、型も決まっている。なので、Typescriptでも対応が可能。
⇨形式は以下のようになる
cookiesToSet = [
  { name: 'sb-access-token', value: 'eyJ...', options: {...} },
  { name: 'sb-refresh-token', value: 'abc...', options: {...} }
]
・cookieStore = Set-Cookieのヘッダーというのはどういうこと？
⇨await cookies()がHTTPレスポンスヘッダーというのがあって、そこにどんどん渡してくれるインターフェースであり、渡され切ったら一気にブラウザのcookieストレージに送信される。


・クッキーの情報が必要な理由としては、そもそも、supabaseは環境に依存しないので、クッキー操作の方法を知らないからその方法を与える。
また、クッキーの中には、、JWT情報があってそこには認証コードみたいなものがあって、それを利用してユーザーが認証済みかそうでないか判断してロールを振り分ける。
今回だとアノンユーザーを取得して、SRLをうまく機能させるようにしたい。


・クッキーをブラウザに追加する必要はあるのか？
⇨RLSポリシーをうまく機能させるために使う

・createServerClient()とは？　
⇨supabaseクライアントを作成する

・supabaseクライアントとは？
⇨supabaseに対してSQL問い合わせができるオブジェクト

・<pre>{JSON.stringify(instruments, null, 2)}</pre>　このコードの解説
⇨preタグ:整形されたデータを整形された状態で表示させる。もしこれ以外のタグであれば改行とかそういうのなくなる。
⇨json文字列に変換する
⇨第一引数:どのデータかを特定
⇨第二引数:フィルター関数　
⇨第三引数:インデント数
⇨メリット:開発中の場合、出力を確認しやすかったり、それをクライアントに出す時もいい感じに表示できる。


◉タスク
・持ってきたデータをどのように活用してフロントエンドで予約の制御をするのか？


◉insertプロセス
・sendform/page.tsxでPOST関数の後にawait InsertReservationData を実行状態を確立
・reservatuion_date/page.tsxをreservation_data/sql.tsxとして、sql操作を書いて置く。insert文も追加する

・POST関数は、一旦コメントアウトしておいた方がいいかもしれない


・元POST関数の呼び出しをSEND_TO_OWNERに変更(sendformのpage.tsx)
・元POST関数のimportを{}バージョンに変更(sendformのpage.tsx)
・mail.tsxのtemplateの呼び出しとimportをEmailTemplateOwnerに変更
・EmailTemplate_Custemer(formData)関数をEmailTemplate.tsxに設定する
・定数だとdefaultが必須なのに二つは書けないから、関数に置き換えていく

・matuott1230@gmail.comにメールが送信完了
・25im0103@i-u.ac.jpにメールが送信完了
⇨resendで送れる形式が・・・.com
　⇨ドメイン認証に使ったアドレスにしてみる。何にも送れなくなった。
・supabaseにメール配信完了
・supabaseに配信した情報を取得できている

・任意の名前@認証済みにのドメインという形式をfrom偽邸することで、toは誰でも送れる。
逆にonboarding@resend.devはテスト用のアドレスなので、resendで登録されているアドレスにしか送れないようになってしまっている。
なので、@マークの後をcramreserveform.comに変更してみる。期待する結果は、無事に自分と学校用のアドレスにメールが送信される.
結果としては、所有者であるアドレスには無事に送信ができた。なので、この書き方自体は問題ない。さらに言えば、独自ドメインからの送信は無事に成功している。
エラーは以下のようになっている。
CustomerData: null error {
  statusCode: 422,
  name: 'validation_error',
  message: 'Invalid `to` field. The email address needs to follow the `email@example.com` or `Name <email@example.com>` format.'
}
おそらくこれは、mailの形式が@~~~~.com形式じゃないとダメで、学校のアドレスのような0-u.ac.jp系はそのルールに反するのでうまく送ることができない。
上記のように言える理由としては、所有者に対しては問題なく遅れていて、形式も.com形式であるため。

・試すこと
  ・.comなら本当に送れるのか？
  ・.com以外には送れないのか、それとも、送るための設定があるのか？を明確にする(理想)
  　⇨そんなことない。多分入力形式が間違っている。
    ・入力データの送信じゃなくて、こちらから別アドレスを指定する
    ⇨うまくいった

・定数を渡せない理由としては、tsのルールに反する
　・toは文字列を期待しているのに、nullになる可能性が存在しているため、安全のためにエラーを出す。
      しかし、stringであることが確定しているので、as string という型アサーションを追加することで、ここはstringで確定しているからエラー出さないでとtsに言える